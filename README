Rachel Lew
Trevor John

COLLABORATION:
    - Josh Pearl: provided insight on the various data type representations
      for the UM as well as clarifying several key implementations points 
    - Jesse Welch: advised several debugging procedures as well as helped
      improve the modularity and level of abstraction in our code.
    - Amanda Hayes: helped us find divergent results in our UM from a
      correctly implemented version in the debugging process

CORRECT IMPLEMENTATION:
    We have implemented our UM so that it successfuly runs all valid
    instruction code that we have passed it (based on our unit tests and the
    tests provided by professor Ramsey).

INCORRECT IMPLEMENTATION:
    As far as all our testsing and the specification is concerned, we do not
    believe there is any incorrect implementation.

DEPARTURES FROM DESIGN:
    1. Registers
        - we removed the halt() instruction from the registers interface and
          made it a um operation
    2. Memory Segments
        - rather than using a stack to implement the unmapped memory segments,
          we utilize a sequence. Our memory segments are 2 sequences, mapped
          and unmapped, and an integer keeping track of the number of mapped
          segments
        - map segment no longer takes in an ID to map but instead uses the
          unmapped ID sequence to select the next ID to map. This ID is
          returned after it has been mapped.
        - we have concealed the index manipulation and acquisition so that it
          all occurs within the map / unmap segment functions
        - most of our changes involve the abstraction of the design, separating
          all the inner workings of the memory segments from the UM. This
          necessitated the creation of the following functions:
                newMem
                loadSegment
                getWord
                segmentLength

ARCHITECTURE:
    Modules:
        registers.h
            Represents the registers (mimicking GPRs) and all operations that
            the registers can perform (add, load value, output, input,
            multiplication, division, conditional move, and bitwise nand). 
            The implementations of the register operations is hidden from the
            UM.
        memseg.h
            Represents all the memory where values can be stored. All
            manipulation of memory is contained within the abstraction, and
            the representation of mapped and unmapped IDs is private to the
            module. (map segment, unmap segment, segmented load, segmented
            store, load program)
        um.h
            Represents the machine as a whole, including the registers and the
            memory segments. It utilizes the memory segments in order to
            retrieve and manipulate values through the registers without
            knowing any underlying implementation of the memory. The UM is
            responsible for the reading and execution of the instructions
            through the manipulation of memory and register operations.

50 MILLION INSTRUCTIONS TIME
    6:48:65 based on looping over five instructions involving loading values,
    mapping a segment, and storing a value 10 million times.

UM UNIT TESTS
    halt.um
        Examines the functionality of the halt function by inserting a halt
        instruction before other instructions and ensuring that the latter
        ones do not execute.
    goto.um
        Validates the loadprogram instruction by loading a different part of
        instruction set and executing starting at that point.
    IO.um
        Takes in a file IO.0, stores each character into a memory segment, and
        then performs a segmented load to output the value at the various
        memory segments.
    add.um
        Performs a series of addition instructions and prints out the
        calculated sums to spell out "PASSED."
    multiply.um
        Performs a series of multiplication instructions and prints out the
        calculated products to spell out "PASSED."
    divide.um
        Performs a series of division instructions and prints out the
        calculated quotients to spell out "PASSED."
    nand.um
        Performs a series of bitwiseNAND instructions and prints out the
        calculated results to spell out "PASSED."
    map.um
        Stressing the map and unmap functions as well as testing the reuse of
        IDs in the UM. Maps several thousand segments and stores values into 
        each of those segments before unmapping all of the segments and then 
        subsequently remapping half of them. It then unmaps one segment and 
        remaps it before unmapping the other half of the remaining mapped 
        elements.
    nomove.um
        Verifies that the move function successfully changes the value in
        registers when the conditional in rC is non 0 by outputing the
        register values that should be updated and the same.
    loadprog.um
        Verifies that the loadprogram operation can move the program counter
        within the $m[0] as well as copy new memory into $m[0] and begin
        operating instructions at that point. We use bitshifting to place a
        32-bit instruction word into memory and then loadprogram at the index
        where this instruction is stored and continue execution.
        
TIME
    - Analysis: 5 hours
    - Peparing: 25 hours
    - Solving: 10 hours
